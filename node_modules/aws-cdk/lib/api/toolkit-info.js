"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors/safe");
const archive_1 = require("../archive");
const logging_1 = require("../logging");
const credentials_1 = require("./aws-auth/credentials");
const bootstrap_environment_1 = require("./bootstrap-environment");
const cloudformation_1 = require("./util/cloudformation");
class ToolkitInfo {
    constructor(props) {
        this.props = props;
        /**
         * A cache of previous uploads done in this session
         */
        this.previousUploads = {};
        this.sdk = props.sdk;
    }
    get bucketUrl() {
        return `https://${this.props.bucketEndpoint}`;
    }
    get bucketName() {
        return this.props.bucketName;
    }
    /**
     * Uploads a data blob to S3 under the specified key prefix.
     * Uses a hash to render the full key and skips upload if an object
     * already exists by this key.
     */
    async uploadIfChanged(data, props) {
        const s3 = await this.props.sdk.s3(this.props.environment.account, this.props.environment.region, credentials_1.Mode.ForWriting);
        const s3KeyPrefix = props.s3KeyPrefix || '';
        const s3KeySuffix = props.s3KeySuffix || '';
        const bucket = this.props.bucketName;
        const hash = archive_1.contentHash(data);
        const filename = `${hash}${s3KeySuffix}`;
        const key = `${s3KeyPrefix}${filename}`;
        const url = `s3://${bucket}/${key}`;
        logging_1.debug(`${url}: checking if already exists`);
        if (await objectExists(s3, bucket, key)) {
            logging_1.debug(`${url}: found (skipping upload)`);
            return { filename, key, hash, changed: false };
        }
        const uploaded = { filename, key, hash, changed: true };
        // Upload if it's new or server-side copy if it was already uploaded previously
        const previous = this.previousUploads[hash];
        if (previous) {
            logging_1.debug(`${url}: copying`);
            await s3.copyObject({
                Bucket: bucket,
                Key: key,
                CopySource: `${bucket}/${previous.key}`
            }).promise();
            logging_1.debug(`${url}: copy complete`);
        }
        else {
            logging_1.debug(`${url}: uploading`);
            await s3.putObject({
                Bucket: bucket,
                Key: key,
                Body: data,
                ContentType: props.contentType
            }).promise();
            logging_1.debug(`${url}: upload complete`);
            this.previousUploads[hash] = uploaded;
        }
        return uploaded;
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     */
    async prepareEcrRepository(asset) {
        const ecr = await this.props.sdk.ecr(this.props.environment.account, this.props.environment.region, credentials_1.Mode.ForWriting);
        let repositoryName;
        if (asset.repositoryName) {
            // Repository name provided by user
            repositoryName = asset.repositoryName;
        }
        else {
            // Repository name based on asset id
            const assetId = asset.id;
            repositoryName = 'cdk/' + assetId.replace(/[:/]/g, '-').toLowerCase();
        }
        let repository;
        try {
            logging_1.debug(`${repositoryName}: checking for repository.`);
            const describeResponse = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
            repository = describeResponse.repositories[0];
        }
        catch (e) {
            if (e.code !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        if (repository) {
            return {
                repositoryUri: repository.repositoryUri,
                repositoryName
            };
        }
        logging_1.debug(`${repositoryName}: creating`);
        const response = await ecr.createRepository({ repositoryName }).promise();
        repository = response.repository;
        // Better put a lifecycle policy on this so as to not cost too much money
        await ecr.putLifecyclePolicy({
            repositoryName,
            lifecyclePolicyText: JSON.stringify(DEFAULT_REPO_LIFECYCLE)
        }).promise();
        return {
            repositoryUri: repository.repositoryUri,
            repositoryName
        };
    }
    /**
     * Get ECR credentials
     */
    async getEcrCredentials() {
        const ecr = await this.props.sdk.ecr(this.props.environment.account, this.props.environment.region, credentials_1.Mode.ForReading);
        logging_1.debug(`Fetching ECR authorization token`);
        const authData = (await ecr.getAuthorizationToken({}).promise()).authorizationData || [];
        if (authData.length === 0) {
            throw new Error('No authorization data received from ECR');
        }
        const token = Buffer.from(authData[0].authorizationToken, 'base64').toString('ascii');
        const [username, password] = token.split(':');
        return {
            username,
            password,
            endpoint: authData[0].proxyEndpoint,
        };
    }
    /**
     * Check if image already exists in ECR repository
     */
    async checkEcrImage(repositoryName, imageTag) {
        const ecr = await this.props.sdk.ecr(this.props.environment.account, this.props.environment.region, credentials_1.Mode.ForReading);
        try {
            logging_1.debug(`${repositoryName}: checking for image ${imageTag}`);
            await ecr.describeImages({ repositoryName, imageIds: [{ imageTag }] }).promise();
            // If we got here, the image already exists. Nothing else needs to be done.
            return true;
        }
        catch (e) {
            if (e.code !== 'ImageNotFoundException') {
                throw e;
            }
        }
        return false;
    }
}
exports.ToolkitInfo = ToolkitInfo;
async function objectExists(s3, bucket, key) {
    try {
        await s3.headObject({ Bucket: bucket, Key: key }).promise();
        return true;
    }
    catch (e) {
        if (e.code === 'NotFound') {
            return false;
        }
        throw e;
    }
}
async function loadToolkitInfo(environment, sdk, stackName) {
    const cfn = await sdk.cloudFormation(environment.account, environment.region, credentials_1.Mode.ForReading);
    const stack = await cloudformation_1.waitForStack(cfn, stackName);
    if (!stack) {
        logging_1.debug('The environment %s doesn\'t have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.', environment.name, stackName, colors.blue(`cdk bootstrap "${environment.name}"`));
        return undefined;
    }
    return new ToolkitInfo({
        sdk, environment,
        bucketName: getOutputValue(stack, bootstrap_environment_1.BUCKET_NAME_OUTPUT),
        bucketEndpoint: getOutputValue(stack, bootstrap_environment_1.BUCKET_DOMAIN_NAME_OUTPUT)
    });
}
exports.loadToolkitInfo = loadToolkitInfo;
function getOutputValue(stack, output) {
    let result;
    if (stack.Outputs) {
        const found = stack.Outputs.find(o => o.OutputKey === output);
        result = found && found.OutputValue;
    }
    if (result === undefined) {
        throw new Error(`The CDK toolkit stack (${stack.StackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
    }
    return result;
}
const DEFAULT_REPO_LIFECYCLE = {
    rules: [
        {
            rulePriority: 100,
            description: 'Retain only 5 images',
            selection: {
                tagStatus: 'any',
                countType: 'imageCountMoreThan',
                countNumber: 5,
            },
            action: { type: 'expire' }
        }
    ]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsc0NBQXVDO0FBQ3ZDLHdDQUF5QztBQUN6Qyx3Q0FBbUM7QUFDbkMsd0RBQThDO0FBQzlDLG1FQUF5RjtBQUN6RiwwREFBcUQ7QUFnQnJELE1BQWEsV0FBVztJQVF0QixZQUE2QixLQUs1QjtRQUw0QixVQUFLLEdBQUwsS0FBSyxDQUtqQztRQVZEOztXQUVHO1FBQ2Msb0JBQWUsR0FBOEIsRUFBRSxDQUFDO1FBUS9ELElBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUN2QixDQUFDO0lBRUQsSUFBVyxTQUFTO1FBQ2xCLE9BQU8sV0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ2hELENBQUM7SUFFRCxJQUFXLFVBQVU7UUFDbkIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLEtBQUssQ0FBQyxlQUFlLENBQUMsSUFBZ0MsRUFBRSxLQUFrQjtRQUMvRSxNQUFNLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLGtCQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFbkgsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsSUFBSSxFQUFFLENBQUM7UUFDNUMsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsSUFBSSxFQUFFLENBQUM7UUFFNUMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7UUFFckMsTUFBTSxJQUFJLEdBQUcscUJBQVcsQ0FBQyxJ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RSwwQ0FBa0IsQ0FBQztRQUNyRCxjQUFjLEVBQUUsY0FBYyxDQUFDLEtBQUssRUFBRSxpREFBeUIsQ0FBQztLQUNqRSxDQUFDLENBQUM7QUFDTCxDQUFDO0FBYkQsMENBYUM7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUErQixFQUFFLE1BQWM7SUFDckUsSUFBSSxNQUEwQixDQUFDO0lBQy9CLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRTtRQUNqQixNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLEtBQUssTUFBTSxDQUFDLENBQUM7UUFDOUQsTUFBTSxHQUFHLEtBQUssSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDO0tBQ3JDO0lBQ0QsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO1FBQ3hCLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLEtBQUssQ0FBQyxTQUFTLG1DQUFtQyxNQUFNLHdDQUF3QyxDQUFDLENBQUM7S0FDN0k7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsTUFBTSxzQkFBc0IsR0FBRztJQUM3QixLQUFLLEVBQUU7UUFDTDtZQUNFLFlBQVksRUFBRSxHQUFHO1lBQ2pCLFdBQVcsRUFBRSxzQkFBc0I7WUFDbkMsU0FBUyxFQUFFO2dCQUNULFNBQVMsRUFBRSxLQUFLO2dCQUNoQixTQUFTLEVBQUUsb0JBQW9CO2dCQUMvQixXQUFXLEVBQUUsQ0FBQzthQUNmO1lBQ0QsTUFBTSxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRTtTQUMzQjtLQUNGO0NBQ0YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjeGFwaSA9IHJlcXVpcmUoJ0Bhd3MtY2RrL2N4LWFwaScpO1xuaW1wb3J0IGF3cyA9IHJlcXVpcmUoJ2F3cy1zZGsnKTtcbmltcG9ydCBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMvc2FmZScpO1xuaW1wb3J0IHsgY29udGVudEhhc2ggfSBmcm9tICcuLi9hcmNoaXZlJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBNb2RlIH0gZnJvbSAnLi9hd3MtYXV0aC9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBCVUNLRVRfRE9NQUlOX05BTUVfT1VUUFVULCBCVUNLRVRfTkFNRV9PVVRQVVQgIH0gZnJvbSAnLi9ib290c3RyYXAtZW52aXJvbm1lbnQnO1xuaW1wb3J0IHsgd2FpdEZvclN0YWNrIH0gZnJvbSAnLi91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IFNESyB9IGZyb20gJy4vdXRpbC9zZGsnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwbG9hZFByb3BzIHtcbiAgczNLZXlQcmVmaXg/OiBzdHJpbmcsXG4gIHMzS2V5U3VmZml4Pzogc3RyaW5nLFxuICBjb250ZW50VHlwZT86IHN0cmluZyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRlZCB7XG4gIGZpbGVuYW1lOiBzdHJpbmc7XG4gIGtleTogc3RyaW5nO1xuICBoYXNoOiBzdHJpbmc7XG4gIGNoYW5nZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyByZWFkb25seSBzZGs6IFNESztcblxuICAvKipcbiAgICogQSBjYWNoZSBvZiBwcmV2aW91cyB1cGxvYWRzIGRvbmUgaW4gdGhpcyBzZXNzaW9uXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHByZXZpb3VzVXBsb2Fkczoge1trZXk6IHN0cmluZ106IFVwbG9hZGVkfSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IHtcbiAgICBzZGs6IFNESyxcbiAgICBidWNrZXROYW1lOiBzdHJpbmcsXG4gICAgYnVja2V0RW5kcG9pbnQ6IHN0cmluZyxcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnRcbiAgfSkge1xuICAgIHRoaXMuc2RrID0gcHJvcHMuc2RrO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXRVcmwoKSB7XG4gICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5wcm9wcy5idWNrZXRFbmRwb2ludH1gO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmJ1Y2tldE5hbWU7XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkcyBhIGRhdGEgYmxvYiB0byBTMyB1bmRlciB0aGUgc3BlY2lmaWVkIGtleSBwcmVmaXguXG4gICAqIFVzZXMgYSBoYXNoIHRvIHJlbmRlciB0aGUgZnVsbCBrZXkgYW5kIHNraXBzIHVwbG9hZCBpZiBhbiBvYmplY3RcbiAgICogYWxyZWFkeSBleGlzdHMgYnkgdGhpcyBrZXkuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgdXBsb2FkSWZDaGFuZ2VkKGRhdGE6IHN0cmluZyB8IEJ1ZmZlciB8IERhdGFWaWV3LCBwcm9wczogVXBsb2FkUHJvcHMpOiBQcm9taXNlPFVwbG9hZGVkPiB7XG4gICAgY29uc3QgczMgPSBhd2FpdCB0aGlzLnByb3BzLnNkay5zMyh0aGlzLnByb3BzLmVudmlyb25tZW50LmFjY291bnQsIHRoaXMucHJvcHMuZW52aXJvbm1lbnQucmVnaW9uLCBNb2RlLkZvcldyaXRpbmcpO1xuXG4gICAgY29uc3QgczNLZXlQcmVmaXggPSBwcm9wcy5zM0tleVByZWZpeCB8fCAnJztcbiAgICBjb25zdCBzM0tleVN1ZmZpeCA9IHByb3BzLnMzS2V5U3VmZml4IHx8ICcnO1xuXG4gICAgY29uc3QgYnVja2V0ID0gdGhpcy5wcm9wcy5idWNrZXROYW1lO1xuXG4gICAgY29uc3QgaGFzaCA9IGNvbnRlbnRIYXNoKGRhdGEpO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gYCR7aGFzaH0ke3MzS2V5U3VmZml4fWA7XG4gICAgY29uc3Qga2V5ID0gYCR7czNLZXlQcmVmaXh9JHtmaWxlbmFtZX1gO1xuICAgIGNvbnN0IHVybCA9IGBzMzovLyR7YnVja2V0fS8ke2tleX1gO1xuXG4gICAgZGVidWcoYCR7dXJsfTogY2hlY2tpbmcgaWYgYWxyZWFkeSBleGlzdHNgKTtcbiAgICBpZiAoYXdhaXQgb2JqZWN0RXhpc3RzKHMzLCBidWNrZXQsIGtleSkpIHtcbiAgICAgIGRlYnVnKGAke3VybH06IGZvdW5kIChza2lwcGluZyB1cGxvYWQpYCk7XG4gICAgICByZXR1cm4geyBmaWxlbmFtZSwga2V5LCBoYXNoLCBjaGFuZ2VkOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGNvbnN0IHVwbG9hZGVkID0geyBmaWxlbmFtZSwga2V5LCBoYXNoLCBjaGFuZ2VkOiB0cnVlIH07XG5cbiAgICAvLyBVcGxvYWQgaWYgaXQncyBuZXcgb3Igc2VydmVyLXNpZGUgY29weSBpZiBpdCB3YXMgYWxyZWFkeSB1cGxvYWRlZCBwcmV2aW91c2x5XG4gICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLnByZXZpb3VzVXBsb2Fkc1toYXNoXTtcbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIGRlYnVnKGAke3VybH06IGNvcHlpbmdgKTtcbiAgICAgIGF3YWl0IHMzLmNvcHlPYmplY3Qoe1xuICAgICAgICBCdWNrZXQ6IGJ1Y2tldCxcbiAgICAgICAgS2V5OiBrZXksXG4gICAgICAgIENvcHlTb3VyY2U6IGAke2J1Y2tldH0vJHtwcmV2aW91cy5rZXl9YFxuICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgZGVidWcoYCR7dXJsfTogY29weSBjb21wbGV0ZWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZyhgJHt1cmx9OiB1cGxvYWRpbmdgKTtcbiAgICAgIGF3YWl0IHMzLnB1dE9iamVjdCh7XG4gICAgICAgIEJ1Y2tldDogYnVja2V0LFxuICAgICAgICBLZXk6IGtleSxcbiAgICAgICAgQm9keTogZGF0YSxcbiAgICAgICAgQ29udGVudFR5cGU6IHByb3BzLmNvbnRlbnRUeXBlXG4gICAgICB9KS5wcm9taXNlKCk7XG4gICAgICBkZWJ1ZyhgJHt1cmx9OiB1cGxvYWQgY29tcGxldGVgKTtcbiAgICAgIHRoaXMucHJldmlvdXNVcGxvYWRzW2hhc2hdID0gdXBsb2FkZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwbG9hZGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmUgYW4gRUNSIHJlcG9zaXRvcnkgZm9yIHVwbG9hZGluZyB0byB1c2luZyBEb2NrZXJcbiAgICovXG4gIHB1YmxpYyBhc3luYyBwcmVwYXJlRWNyUmVwb3NpdG9yeShhc3NldDogY3hhcGkuQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnkpOiBQcm9taXNlPEVjclJlcG9zaXRvcnlJbmZvPiB7XG4gICAgY29uc3QgZWNyID0gYXdhaXQgdGhpcy5wcm9wcy5zZGsuZWNyKHRoaXMucHJvcHMuZW52aXJvbm1lbnQuYWNjb3VudCwgdGhpcy5wcm9wcy5lbnZpcm9ubWVudC5yZWdpb24sIE1vZGUuRm9yV3JpdGluZyk7XG4gICAgbGV0IHJlcG9zaXRvcnlOYW1lO1xuICAgIGlmICggYXNzZXQucmVwb3NpdG9yeU5hbWUgKSB7XG4gICAgICAvLyBSZXBvc2l0b3J5IG5hbWUgcHJvdmlkZWQgYnkgdXNlclxuICAgICAgcmVwb3NpdG9yeU5hbWUgPSBhc3NldC5yZXBvc2l0b3J5TmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVwb3NpdG9yeSBuYW1lIGJhc2VkIG9uIGFzc2V0IGlkXG4gICAgICBjb25zdCBhc3NldElkID0gYXNzZXQuaWQ7XG4gICAgICByZXBvc2l0b3J5TmFtZSA9ICdjZGsvJyArIGFzc2V0SWQucmVwbGFjZSgvWzovXS9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgbGV0IHJlcG9zaXRvcnk7XG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogY2hlY2tpbmcgZm9yIHJlcG9zaXRvcnkuYCk7XG4gICAgICBjb25zdCBkZXNjcmliZVJlc3BvbnNlID0gYXdhaXQgZWNyLmRlc2NyaWJlUmVwb3NpdG9yaWVzKHsgcmVwb3NpdG9yeU5hbWVzOiBbcmVwb3NpdG9yeU5hbWVdIH0pLnByb21pc2UoKTtcbiAgICAgIHJlcG9zaXRvcnkgPSBkZXNjcmliZVJlc3BvbnNlLnJlcG9zaXRvcmllcyFbMF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSAhPT0gJ1JlcG9zaXRvcnlOb3RGb3VuZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuICAgIH1cblxuICAgIGlmIChyZXBvc2l0b3J5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXBvc2l0b3J5VXJpOiByZXBvc2l0b3J5LnJlcG9zaXRvcnlVcmkhLFxuICAgICAgICByZXBvc2l0b3J5TmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhgJHtyZXBvc2l0b3J5TmFtZX06IGNyZWF0aW5nYCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlY3IuY3JlYXRlUmVwb3NpdG9yeSh7IHJlcG9zaXRvcnlOYW1lIH0pLnByb21pc2UoKTtcbiAgICByZXBvc2l0b3J5ID0gcmVzcG9uc2UucmVwb3NpdG9yeSE7XG5cbiAgICAvLyBCZXR0ZXIgcHV0IGEgbGlmZWN5Y2xlIHBvbGljeSBvbiB0aGlzIHNvIGFzIHRvIG5vdCBjb3N0IHRvbyBtdWNoIG1vbmV5XG4gICAgYXdhaXQgZWNyLnB1dExpZmVjeWNsZVBvbGljeSh7XG4gICAgICByZXBvc2l0b3J5TmFtZSxcbiAgICAgIGxpZmVjeWNsZVBvbGljeVRleHQ6IEpTT04uc3RyaW5naWZ5KERFRkFVTFRfUkVQT19MSUZFQ1lDTEUpXG4gICAgfSkucHJvbWlzZSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcG9zaXRvcnlVcmk6IHJlcG9zaXRvcnkucmVwb3NpdG9yeVVyaSEsXG4gICAgICByZXBvc2l0b3J5TmFtZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IEVDUiBjcmVkZW50aWFsc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldEVjckNyZWRlbnRpYWxzKCk6IFByb21pc2U8RWNyQ3JlZGVudGlhbHM+IHtcbiAgICBjb25zdCBlY3IgPSBhd2FpdCB0aGlzLnByb3BzLnNkay5lY3IodGhpcy5wcm9wcy5lbnZpcm9ubWVudC5hY2NvdW50LCB0aGlzLnByb3BzLmVudmlyb25tZW50LnJlZ2lvbiwgTW9kZS5Gb3JSZWFkaW5nKTtcblxuICAgIGRlYnVnKGBGZXRjaGluZyBFQ1IgYXV0aG9yaXphdGlvbiB0b2tlbmApO1xuICAgIGNvbnN0IGF1dGhEYXRhID0gIChhd2FpdCBlY3IuZ2V0QXV0aG9yaXphdGlvblRva2VuKHsgfSkucHJvbWlzZSgpKS5hdXRob3JpemF0aW9uRGF0YSB8fCBbXTtcbiAgICBpZiAoYXV0aERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGF1dGhvcml6YXRpb24gZGF0YSByZWNlaXZlZCBmcm9tIEVDUicpO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbiA9IEJ1ZmZlci5mcm9tKGF1dGhEYXRhWzBdLmF1dGhvcml6YXRpb25Ub2tlbiEsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKTtcbiAgICBjb25zdCBbdXNlcm5hbWUsIHBhc3N3b3JkXSA9IHRva2VuLnNwbGl0KCc6Jyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIGVuZHBvaW50OiBhdXRoRGF0YVswXS5wcm94eUVuZHBvaW50ISxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGltYWdlIGFscmVhZHkgZXhpc3RzIGluIEVDUiByZXBvc2l0b3J5XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY2hlY2tFY3JJbWFnZShyZXBvc2l0b3J5TmFtZTogc3RyaW5nLCBpbWFnZVRhZzogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZWNyID0gYXdhaXQgdGhpcy5wcm9wcy5zZGsuZWNyKHRoaXMucHJvcHMuZW52aXJvbm1lbnQuYWNjb3VudCwgdGhpcy5wcm9wcy5lbnZpcm9ubWVudC5yZWdpb24sIE1vZGUuRm9yUmVhZGluZyk7XG5cbiAgICB0cnkge1xuICAgICAgZGVidWcoYCR7cmVwb3NpdG9yeU5hbWV9OiBjaGVja2luZyBmb3IgaW1hZ2UgJHtpbWFnZVRhZ31gKTtcbiAgICAgIGF3YWl0IGVjci5kZXNjcmliZUltYWdlcyh7IHJlcG9zaXRvcnlOYW1lLCBpbWFnZUlkczogW3sgaW1hZ2VUYWcgfV0gfSkucHJvbWlzZSgpO1xuXG4gICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgdGhlIGltYWdlIGFscmVhZHkgZXhpc3RzLiBOb3RoaW5nIGVsc2UgbmVlZHMgdG8gYmUgZG9uZS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdJbWFnZU5vdEZvdW5kRXhjZXB0aW9uJykgeyB0aHJvdyBlOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWNyUmVwb3NpdG9yeUluZm8ge1xuICByZXBvc2l0b3J5VXJpOiBzdHJpbmc7XG4gIHJlcG9zaXRvcnlOYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWNyQ3JlZGVudGlhbHMge1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBvYmplY3RFeGlzdHMoczM6IGF3cy5TMywgYnVja2V0OiBzdHJpbmcsIGtleTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgczMuaGVhZE9iamVjdCh7IEJ1Y2tldDogYnVja2V0LCBLZXk6IGtleSB9KS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5jb2RlID09PSAnTm90Rm91bmQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFRvb2xraXRJbmZvKGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCwgc2RrOiBTREssIHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxUb29sa2l0SW5mbyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBjZm4gPSBhd2FpdCBzZGsuY2xvdWRGb3JtYXRpb24oZW52aXJvbm1lbnQuYWNjb3VudCwgZW52aXJvbm1lbnQucmVnaW9uLCBNb2RlLkZvclJlYWRpbmcpO1xuICBjb25zdCBzdGFjayA9IGF3YWl0IHdhaXRGb3JTdGFjayhjZm4sIHN0YWNrTmFtZSk7XG4gIGlmICghc3RhY2spIHtcbiAgICBkZWJ1ZygnVGhlIGVudmlyb25tZW50ICVzIGRvZXNuXFwndCBoYXZlIHRoZSBDREsgdG9vbGtpdCBzdGFjayAoJXMpIGluc3RhbGxlZC4gVXNlICVzIHRvIHNldHVwIHlvdXIgZW52aXJvbm1lbnQgZm9yIHVzZSB3aXRoIHRoZSB0b29sa2l0LicsXG4gICAgICAgIGVudmlyb25tZW50Lm5hbWUsIHN0YWNrTmFtZSwgY29sb3JzLmJsdWUoYGNkayBib290c3RyYXAgXCIke2Vudmlyb25tZW50Lm5hbWV9XCJgKSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gbmV3IFRvb2xraXRJbmZvKHtcbiAgICBzZGssIGVudmlyb25tZW50LFxuICAgIGJ1Y2tldE5hbWU6IGdldE91dHB1dFZhbHVlKHN0YWNrLCBCVUNLRVRfTkFNRV9PVVRQVVQpLFxuICAgIGJ1Y2tldEVuZHBvaW50OiBnZXRPdXRwdXRWYWx1ZShzdGFjaywgQlVDS0VUX0RPTUFJTl9OQU1FX09VVFBVVClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE91dHB1dFZhbHVlKHN0YWNrOiBhd3MuQ2xvdWRGb3JtYXRpb24uU3RhY2ssIG91dHB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHJlc3VsdDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBpZiAoc3RhY2suT3V0cHV0cykge1xuICAgIGNvbnN0IGZvdW5kID0gc3RhY2suT3V0cHV0cy5maW5kKG8gPT4gby5PdXRwdXRLZXkgPT09IG91dHB1dCk7XG4gICAgcmVzdWx0ID0gZm91bmQgJiYgZm91bmQuT3V0cHV0VmFsdWU7XG4gIH1cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgQ0RLIHRvb2xraXQgc3RhY2sgKCR7c3RhY2suU3RhY2tOYW1lfSkgZG9lcyBub3QgaGF2ZSBhbiBvdXRwdXQgbmFtZWQgJHtvdXRwdXR9LiBVc2UgJ2NkayBib290c3RyYXAnIHRvIGNvcnJlY3QgdGhpcy5gKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBERUZBVUxUX1JFUE9fTElGRUNZQ0xFID0ge1xuICBydWxlczogW1xuICAgIHtcbiAgICAgIHJ1bGVQcmlvcml0eTogMTAwLFxuICAgICAgZGVzY3JpcHRpb246ICdSZXRhaW4gb25seSA1IGltYWdlcycsXG4gICAgICBzZWxlY3Rpb246IHtcbiAgICAgICAgdGFnU3RhdHVzOiAnYW55JyxcbiAgICAgICAgY291bnRUeXBlOiAnaW1hZ2VDb3VudE1vcmVUaGFuJyxcbiAgICAgICAgY291bnROdW1iZXI6IDUsXG4gICAgICB9LFxuICAgICAgYWN0aW9uOiB7IHR5cGU6ICdleHBpcmUnIH1cbiAgICB9XG4gIF1cbn07XG4iXX0=